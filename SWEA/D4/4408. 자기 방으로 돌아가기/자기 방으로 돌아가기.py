# 자기 방으로 돌아가기

# 이번 문제도 처음에 조금 난해했음.
# 처음엔 출발지와 도착지의 값만 1로 갱신해서 찾아가볼까 생각했으나, 이내 무리라고 판단함.
# 종이에 그림을 대충 그려보자, 포인터를 이동하며 해당 포인터에 걸리는 선 개수의 최댓값을 구하면 되겠다고 생각함.
# 그래서 무식하게 0부터 400까지 만들어놓고 거기서 두 지점 사이를 전부 +1 했더니 틀림.
# 당연함. 1번과 2번은 같은 복도를 마주보고 있기 때문에, 200으로 스케일링을 해 줘야 했음.
# 수학으로 들어가 머리가 조금 아파서 여기서 검색 찬스. 그냥 2로 나누면 딱 맞아떨어지는 듯함.

if __name__ == "__main__":
    T = int(input())
    ans = []

    for t in range(1, T + 1):
        N = int(input())
        corridor = [0] * 201

        for _ in range(N):
            a, b = map(int, input().split())

            # 범위 계산시 1을 더해줘야 함.
            # 이유는 해당 문제의 복도 형태에서 마주보는 홀수와 짝수에 1을 더하고 2로 나눈 값이 서로 같기 때문.
            if a < b:
                s = (a + 1) // 2
                e = (b + 1) // 2
            
            else:
                s = (b + 1) // 2
                e = (a + 1) // 2
            
            for i in range(s, e + 1):
                corridor[i] += 1

        ans.append(f'#{t} {max(corridor)}')
    
    print("\n".join(ans))